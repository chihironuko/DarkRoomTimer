<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>シングルページ タイマー（ビープ）</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif; padding: 24px; max-width:720px; margin:auto; }
  h1 { margin-bottom: 8px; }
  label { display:block; margin-top:12px; }
  input[type="number"] { width:120px; padding:6px; font-size:16px; }
  .controls { margin-top:16px; }
  button { padding:8px 12px; margin-right:8px; font-size:15px; }
  #status { margin-top:18px; font-size:18px; }
  #log { margin-top:12px; max-height:160px; overflow:auto; background:#f8f8f8; padding:8px; border-radius:6px; font-size:13px; }
  .small { font-size:13px; color:#666; }
</style>
</head>
<body>
  <h1>タイマー（ビープ）</h1>
  <div class="small">総経過時間とビープ間隔を分で指定。ビープは「経過した分数」と同じ回数鳴ります。</div>

  <form id="form" onsubmit="return false;">
    <label>
      総経過時間（分）:
      <input type="number" id="totalMinutes" value="5" min="1" required>
    </label>

    <label>
      ビープ間隔（分）:
      <input type="number" id="beepSpan" value="1" min="1" required>
    </label>

    <div class="controls">
      <button id="startBtn" type="button">開始</button>
      <button id="pauseBtn" type="button" disabled>一時停止</button>
      <button id="resetBtn" type="button" disabled>リセット</button>
    </div>
  </form>

  <div id="status">
    <div>経過: <span id="elapsedDisplay">0分0秒</span></div>
    <div>残り: <span id="remainingDisplay">-</span></div>
    <div id="nextBeepInfo" class="small">次のビープ: -</div>
  </div>

  <div id="log"></div>
<script>
(() => {
  // 要素参照（省略）
  const totalMinutesInput = document.getElementById('totalMinutes');
  const beepSpanInput = document.getElementById('beepSpan');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBtn = document.getElementById('resetBtn');
  const elapsedDisplay = document.getElementById('elapsedDisplay');
  const remainingDisplay = document.getElementById('remainingDisplay');
  const nextBeepInfo = document.getElementById('nextBeepInfo');
  const log = document.getElementById('log');

  let timerIntervalId = null;
  let startTime = null;
  let pausedAt = null;
  let totalMillis = 0;
  let lastElapsedMinutes = 0;
  let audioCtx = null;
  let gongBuffer = null; // ← gong音のキャッシュ

  function logMsg(msg) {
    const t = new Date().toLocaleTimeString();
    log.insertAdjacentHTML('afterbegin', `<div>[${t}] ${msg}</div>`);
  }

  function ensureAudioContext() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
  }

  // gong.wav を読み込んでキャッシュ
  async function loadGong() {
    if (!audioCtx) ensureAudioContext();
    if (gongBuffer) return gongBuffer;
    const res = await fetch('gong.wav');
    const arrayBuffer = await res.arrayBuffer();
    gongBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    return gongBuffer;
  }

  // gong.wav を再生
  function playGong() {
    if (!gongBuffer) return;
    const src = audioCtx.createBufferSource();
    src.buffer = gongBuffer;
    src.connect(audioCtx.destination);
    src.start();
  }

  // 単一の短いビープ音
  function singleBeepAt(timeOffsetSec) {
    const dur = 0.18;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(880, audioCtx.currentTime + timeOffsetSec);
    gain.gain.setValueAtTime(0.001, audioCtx.currentTime + timeOffsetSec);
    gain.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + timeOffsetSec + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + timeOffsetSec + dur);

    osc.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(audioCtx.currentTime + timeOffsetSec);
    osc.stop(audioCtx.currentTime + timeOffsetSec + dur + 0.01);
  }

  function beepMultiple(times, beepGapSec = 0.35) {
    if (!times || times <= 0) return;
    ensureAudioContext();
    for (let i = 0; i < times; i++) {
      singleBeepAt(i * beepGapSec);
    }
  }

  function formatDuration(ms) {
    const totalSec = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(totalSec / 60);
    const s = totalSec % 60;
    return `${m}分${s}秒`;
  }

  function updateDisplays() {
    const now = Date.now();
    const elapsedMs = (startTime !== null) ? (now - startTime) : (pausedAt || 0);
    const remainingMs = Math.max(0, totalMillis - elapsedMs);
    const elapsedMinutes = Math.floor(elapsedMs / 60000);
    const elapsedSeconds = Math.floor((elapsedMs % 60000) / 1000);

    elapsedDisplay.textContent = `${elapsedMinutes}分${elapsedSeconds}秒`;
    remainingDisplay.textContent = formatDuration(remainingMs);

    const beepSpan = Math.max(1, parseInt(beepSpanInput.value, 10) || 1);
    const nextBeepInMinutes = beepSpan - (elapsedMinutes % beepSpan);
    nextBeepInfo.textContent = `次のビープは ${ (elapsedMinutes % beepSpan === 0) ? '直前（今が該当）' : nextBeepInMinutes + ' 分以内'} に来ます（経過 ${elapsedMinutes} 分）.`;

    if (elapsedMinutes > lastElapsedMinutes) {
      lastElapsedMinutes = elapsedMinutes;
      if (elapsedMinutes > 0 && (elapsedMinutes % beepSpan === 0)) {
        logMsg(`${elapsedMinutes}分経過 → ${elapsedMinutes} 回ビープします`);
        beepMultiple(elapsedMinutes);
      }
    }

    if (elapsedMs >= totalMillis) {
      stopTimer(false);
      logMsg('総経過時間に到達しました。');
    }
  }

  function startTimer() {
    const totalMin = Math.max(1, parseInt(totalMinutesInput.value, 10) || 1);
    const beepSpan = Math.max(1, parseInt(beepSpanInput.value, 10) || 1);

    totalMinutesInput.value = totalMin;
    beepSpanInput.value = beepSpan;
    totalMillis = totalMin * 60 * 1000;

    ensureAudioContext();
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().catch(()=>{});
    }

    // gong を事前にロード
    loadGong().then(() => {
      logMsg('1分待機中…');
      startBtn.disabled = true;
      pauseBtn.disabled = true;

      setTimeout(() => {
        logMsg('開始しました');
        playGong(); // ← AudioContext 経由で鳴らす

        if (!startTime) {
          startTime = Date.now();
          lastElapsedMinutes = -1;
          pausedAt = null;
        } else if (pausedAt !== null) {
          const now = Date.now();
          startTime = now - pausedAt;
          pausedAt = null;
        }

        if (!timerIntervalId) {
          timerIntervalId = setInterval(updateDisplays, 1000);
          updateDisplays();
        }

        pauseBtn.disabled = false;
        resetBtn.disabled = false;
      }, 60000);
    });
  }

  function pauseTimer() {
    if (!timerIntervalId) return;
    clearInterval(timerIntervalId);
    timerIntervalId = null;
    pausedAt = Date.now() - startTime;
    startTime = null;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    resetBtn.disabled = false;
    logMsg('一時停止しました');
  }

  function stopTimer(reset = true) {
    if (timerIntervalId) {
      clearInterval(timerIntervalId);
      timerIntervalId = null;
    }
    if (reset) {
      startTime = null;
      pausedAt = null;
      lastElapsedMinutes = 0;
      elapsedDisplay.textContent = '0分0秒';
      remainingDisplay.textContent = '-';
      nextBeepInfo.textContent = '-';
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      resetBtn.disabled = true;
      logMsg('リセットしました');
    } else {
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      resetBtn.disabled = false;
    }
  }

  function resetAll() {
    stopTimer(true);
  }

  startBtn.addEventListener('click', () => {
    startTimer();
  });
  pauseBtn.addEventListener('click', () => {
    pauseTimer();
  });
  resetBtn.addEventListener('click', () => {
    resetAll();
  });

  resetAll();

  document.getElementById('form').addEventListener('submit', (e) => {
    e.preventDefault();
    startTimer();
  });

  window.addEventListener('beforeunload', () => {
    if (audioCtx && audioCtx.state !== 'closed') {
      try { audioCtx.close(); } catch (e) {}
    }
  });
})();
</script>
</body>
</html>
